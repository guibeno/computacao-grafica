
import glfw
from OpenGL.GL import *
import numpy as np
import ctypes
import math
import time

# ---------------- MATRIZES -----------------
def rotate_y(angulo):
    c, s = math.cos(angulo), math.sin(angulo)
    return np.array([
        [ c, 0, s, 0],
        [ 0, 1, 0, 0],
        [-s, 0, c, 0],
        [ 0, 0, 0, 1]
    ], dtype=np.float32)
    
def rotate_z(angulo_radianos): 
    c = math.cos(angulo_radianos) 
    s = math.sin(angulo_radianos) 
    return np.array([
        [ c, -s, 0, 0],
        [ s, c, 0, 0],
        [ 0, 0, 1, 0],
        [ 0, 0, 0, 1]
        ], dtype=np.float32)
    
def rotate_x(angulo_radianos):
    c = math.cos(angulo_radianos)
    s = math.sin(angulo_radianos)
    return np.array([
        [ 1, 0, 0, 0],
        [ 0, c, -s, 0],
        [ 0, s, c, 0],
        [ 0, 0, 0, 1]
        ], dtype=np.float32)

def matrix_translacao(tx, ty, tz):
    return np.array([
        [1, 0, 0, tx],
        [0, 1, 0, ty],
        [0, 0, 1, tz],
        [0, 0, 0, 1]
    ], dtype=np.float32)
    
def matrix_escala(sx,sy,sz):
    return np.array([
        [sx,0,0,0],
        [0,sy,0,0],
        [0,0,sz,0],
        [0,0,0,1]
    ],dtype=np.float32)

def get_view_matrix(eye, target, up):
    f = target - eye
    f /= np.linalg.norm(f)
    u = up / np.linalg.norm(up)
    s = np.cross(f, u)
    s /= np.linalg.norm(s)
    u = np.cross(s, f)

    M = np.identity(4, dtype=np.float32)
    M[0, :3] = s
    M[1, :3] = u
    M[2, :3] = -f
    M[0, 3] = -np.dot(s, eye)
    M[1, 3] = -np.dot(u, eye)
    M[2, 3] = np.dot(f, eye)
    return M

def get_projection_matrix(fov, aspect_ratio, near, far):
    f = 1.0 / math.tan(math.radians(fov) / 2.0)
    proj = np.zeros((4,4), dtype=np.float32)
    proj[0,0] = f / aspect_ratio
    proj[1,1] = f
    proj[2,2] = (far + near) / (near - far)
    proj[2,3] = (2 * far * near) / (near - far)
    proj[3,2] = -1.0
    return proj

def load_shader(code, shader_type):
    shader = glCreateShader(shader_type)
    glShaderSource(shader, code)
    glCompileShader(shader)
    if not glGetShaderiv(shader, GL_COMPILE_STATUS):
        raise RuntimeError(glGetShaderInfoLog(shader))
    return shader

muda_posicao_camera_z = 5
muda_posicao_camera_x = 0
muda_posicao_camera_y = 0
rotacao_x = 0
rotacao_y = 0

def key_callback(window, key, scancode, action, mods):
    global muda_posicao_camera_z
    global muda_posicao_camera_x
    global muda_posicao_camera_y 
    global rotacao_x
    global rotacao_y
    if key == glfw.KEY_S and action == glfw.PRESS:
        muda_posicao_camera_z += 0.20
    if key == glfw.KEY_W and action == glfw.PRESS:
        muda_posicao_camera_z -= 0.20
        
        
    if key == glfw.KEY_D and action == glfw.PRESS:
        muda_posicao_camera_x += 0.20
    if key == glfw.KEY_A and action == glfw.PRESS:
        muda_posicao_camera_x -= 0.20
        
    if key == glfw.KEY_LEFT_SHIFT and action == glfw.PRESS:
        muda_posicao_camera_y += 0.20
    if key == glfw.KEY_SPACE and action == glfw.PRESS:
        muda_posicao_camera_y -= 0.20
        
    if key == glfw.KEY_RIGHT and action == glfw.PRESS:
        rotacao_y += 0.20
    if key == glfw.KEY_LEFT and action == glfw.PRESS:
        rotacao_y -= 0.20
        
    if key == glfw.KEY_UP and action == glfw.PRESS:
        rotacao_x += 0.20
    if key == glfw.KEY_DOWN and action == glfw.PRESS:
        rotacao_x -= 0.20
        
    
#    if key == glfw.KEY_T and action == glfw.PRESS:
#        translate_object(...)
#    if key == glfw.KEY_S and action == glfw.PRESS:
#        scale_object(...)
#

def main():
    if not glfw.init():
        raise SystemExit('Falha ao inicializar GLFW')

    glfw.window_hint(glfw.CONTEXT_VERSION_MAJOR, 3)
    glfw.window_hint(glfw.CONTEXT_VERSION_MINOR, 3)
    glfw.window_hint(glfw.OPENGL_PROFILE, glfw.OPENGL_CORE_PROFILE)

    window = glfw.create_window(800, 600, 'Triângulo 3D MVP', None, None)
    glfw.make_context_current(window)
    
    glfw.set_key_callback(window, key_callback)
   
    



    vertices = np.array([
-0.5, -0.5, -1.0, 1.0, 0.0, 0.0, #V1
0.5, -0.5, -1.0, 0.0, 1.0, 0.0, #V2
0.0, 0.5, -1.0, 0.0, 0.0, 1.0 #V3
], dtype=np.float32)
    
    square_vertices = np.array([
-0.3, -0.3, -2.0, 1.0, 0.5, 0.2, # T1 V1
0.3, -0.3, -2.0, 1.0, 0.5, 0.2, # T1 V2
0.3, 0.3, -2.0, 1.0, 0.5, 0.2, # T1 V3
-0.3, -0.3, -2.0, 1.0, 0.5, 0.2, # T2 V1
0.3, 0.3, -2.0, 1.0, 0.5, 0.2, # T2 V2
-0.3, 0.3, -2.0, 1.0, 0.5, 0.2 # T2 V3
], dtype=np.float32)

    VAO = glGenVertexArrays(1)
    VBO = glGenBuffers(1)

    glBindVertexArray(VAO)
    glBindBuffer(GL_ARRAY_BUFFER, VBO)
    glBufferData(GL_ARRAY_BUFFER, vertices.nbytes, vertices, GL_STATIC_DRAW)

    # posição
    glEnableVertexAttribArray(0)
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6*4, ctypes.c_void_p(0))
    
    glEnableVertexAttribArray(1)
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6*4, ctypes.c_void_p(3*4))

    glBindBuffer(GL_ARRAY_BUFFER, 0)
    glBindVertexArray(0)
    
    # --- vbo/vao quadrado
    
    vao_quadrado = glGenVertexArrays(1)
    vbo_quadrado = glGenBuffers(1)
    
    glBindVertexArray(vao_quadrado)
    glBindBuffer(GL_ARRAY_BUFFER,vbo_quadrado)
    glBufferData(GL_ARRAY_BUFFER, square_vertices.nbytes, square_vertices, GL_STATIC_DRAW)

    
     # posição
    glEnableVertexAttribArray(0)
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6*4, ctypes.c_void_p(0))
    
    glEnableVertexAttribArray(1)
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6*4, ctypes.c_void_p(3*4))
    
    glBindBuffer(GL_ARRAY_BUFFER, 0)
    glBindVertexArray(0)
    

    with open('vertex_shader.glsl', 'r') as f:
        vs_code = f.read()
    with open('fragment_shader.glsl', 'r') as f:
        fs_code = f.read()

    vertex_shader = load_shader(vs_code, GL_VERTEX_SHADER)
    fragment_shader = load_shader(fs_code, GL_FRAGMENT_SHADER)

    shader_program = glCreateProgram()
    glAttachShader(shader_program, vertex_shader)
    glAttachShader(shader_program, fragment_shader)
    glLinkProgram(shader_program)

    glDeleteShader(vertex_shader)
    glDeleteShader(fragment_shader)

    glUseProgram(shader_program)
    mvp_loc = glGetUniformLocation(shader_program, 'uMVP')

    glEnable(GL_DEPTH_TEST)

    start = time.time()
    aspect = 800/600
    
    while not glfw.window_should_close(window):
        glClearColor(0.2, 0.2, 0.25, 1.0)
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)

        t = time.time() - start
        
        model = rotate_y(rotacao_y) @ matrix_escala(1.0,1.0,1.0) @ rotate_x(rotacao_x)
        
        
        
        
        # Posição da camera
        eye = np.array([muda_posicao_camera_x,muda_posicao_camera_y, muda_posicao_camera_z], dtype=np.float32)
        # Para onde a camera olha
        target = np.array([0, 0, 1.5], dtype=np.float32)
        # Vetor "para cima"
        up = np.array([0.0, 1.0, 0.0], dtype=np.float32)
        view_matrix = get_view_matrix(eye, target, up)

        proj = get_projection_matrix(45.0, aspect, 0.1, 100.0)
        

        mvp = proj @ view_matrix @ model
        glUniformMatrix4fv(mvp_loc, 1, GL_FALSE, mvp.T)

        glBindVertexArray(VAO)
        glDrawArrays(GL_TRIANGLES, 0, 3)
        
        glBindVertexArray(vao_quadrado)
        glDrawArrays(GL_TRIANGLES, 0, 6)

        glfw.swap_buffers(window)
        glfw.poll_events()

    glfw.terminate()


if __name__ == '__main__':
    main()
